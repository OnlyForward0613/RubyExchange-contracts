{
  "address": "0x160E10d118a02DAfa1883f171A4c7aA257C41Ca2",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "merkleRoot_",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "merkleRoot",
          "type": "bytes32"
        }
      ],
      "name": "NewMerkleRoot",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "accountLimit",
          "type": "uint256"
        }
      ],
      "name": "PoolAccountLimit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "poolCap",
          "type": "uint256"
        }
      ],
      "name": "PoolCap",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        }
      ],
      "name": "getPoolAccountLimit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        }
      ],
      "name": "getPoolCap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "isAccountVerified",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "merkleRoot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "accountLimit",
          "type": "uint256"
        }
      ],
      "name": "setPoolAccountLimit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "poolCap",
          "type": "uint256"
        }
      ],
      "name": "setPoolCap",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "merkleRoot_",
          "type": "bytes32"
        }
      ],
      "name": "updateMerkleRoot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "bytes32[]",
          "name": "merkleProof",
          "type": "bytes32[]"
        }
      ],
      "name": "verifyAddress",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x26daa018d5c710676f63edd5cf685a16bf58a9838d99bdde186ee0c95b6ce2e3",
  "receipt": {
    "to": "0x0000000000000000000000000000000000000000",
    "from": "0x0fe812C977646525E824D5dCC3f37A0Cf153B13b",
    "contractAddress": "0x160E10d118a02DAfa1883f171A4c7aA257C41Ca2",
    "transactionIndex": 0,
    "gasUsed": "643236",
    "logsBloom": "0x00002000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000001000000000000000000800000000000040000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000080000000000000100000000000000000000000000000010000002000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000020000001000000200000000000000000000001000000000000000000000000000000",
    "blockHash": "0xb396098fb7dc7b1cb087332747d259e5b98ef416dd69c9b3681bddd58fbb164d",
    "transactionHash": "0x26daa018d5c710676f63edd5cf685a16bf58a9838d99bdde186ee0c95b6ce2e3",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 186756,
        "transactionHash": "0x26daa018d5c710676f63edd5cf685a16bf58a9838d99bdde186ee0c95b6ce2e3",
        "address": "0x160E10d118a02DAfa1883f171A4c7aA257C41Ca2",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000fe812c977646525e824d5dcc3f37a0cf153b13b"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xb396098fb7dc7b1cb087332747d259e5b98ef416dd69c9b3681bddd58fbb164d"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 186756,
        "transactionHash": "0x26daa018d5c710676f63edd5cf685a16bf58a9838d99bdde186ee0c95b6ce2e3",
        "address": "0x160E10d118a02DAfa1883f171A4c7aA257C41Ca2",
        "topics": [
          "0x87a8ed40e9bdf0609701a63c1db365301c953ffa230215ac92903d4af963e7cd",
          "0x0000000000000000000000000000000000000000000000000000000000000000"
        ],
        "data": "0x000000000000000000000000000000000000000000000000000000000054dd1e",
        "logIndex": 1,
        "blockHash": "0xb396098fb7dc7b1cb087332747d259e5b98ef416dd69c9b3681bddd58fbb164d"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 186756,
        "transactionHash": "0x26daa018d5c710676f63edd5cf685a16bf58a9838d99bdde186ee0c95b6ce2e3",
        "address": "0x160E10d118a02DAfa1883f171A4c7aA257C41Ca2",
        "topics": [
          "0x2f4f633f2174c8fce0ce6b22ea3cc69675584063adfd3d25e4dc3fd50cb631fc"
        ],
        "data": "0xca0f8c7ee1addcc5fce6a7c989ba3f210db065c36c276b71b8c8253a339318a3",
        "logIndex": 2,
        "blockHash": "0xb396098fb7dc7b1cb087332747d259e5b98ef416dd69c9b3681bddd58fbb164d"
      }
    ],
    "blockNumber": 186756,
    "cumulativeGasUsed": "643236",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xca0f8c7ee1addcc5fce6a7c989ba3f210db065c36c276b71b8c8253a339318a3"
  ],
  "numDeployments": 1,
  "solcInputHash": "8ca980d51c658bcb6e0b1d5c9f9ee0b7",
  "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"NewMerkleRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountLimit\",\"type\":\"uint256\"}],\"name\":\"PoolAccountLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolCap\",\"type\":\"uint256\"}],\"name\":\"PoolCap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"getPoolAccountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"getPoolCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAccountVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"accountLimit\",\"type\":\"uint256\"}],\"name\":\"setPoolAccountLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolCap\",\"type\":\"uint256\"}],\"name\":\"setPoolCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"name\":\"updateMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"merkleRoot_\":\"bytes32 that represent a merkle root node. This is generated off chain with the list of qualifying addresses.\"}},\"getPoolAccountLimit(address)\":{\"params\":{\"poolAddress\":\"address of the pool\"},\"returns\":{\"_0\":\"max mintable amount of the lp token per account\"}},\"getPoolCap(address)\":{\"params\":{\"poolAddress\":\"address of the pool\"}},\"isAccountVerified(address)\":{\"params\":{\"account\":\"the address to check if it has been verified\"},\"returns\":{\"_0\":\"a boolean value representing whether the account has been verified in the past or the present merkle tree\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setPoolAccountLimit(address,uint256)\":{\"params\":{\"accountLimit\":\"the max number of the pool token a single user can mint\",\"poolAddress\":\"address of the pool\"}},\"setPoolCap(address,uint256)\":{\"params\":{\"poolAddress\":\"address of the pool\",\"poolCap\":\"the max total supply of the pool token\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"updateMerkleRoot(bytes32)\":{\"params\":{\"merkleRoot_\":\"a new merkle root node that contains a list of deposit allowed addresses\"}},\"verifyAddress(address,bytes32[])\":{\"params\":{\"account\":\"address to confirm its existence in the merkle tree\",\"merkleProof\":\"data that is used to prove the existence of given parameters. This is generated during the creation of the merkle tree. Users should retrieve this data off-chain.\"},\"returns\":{\"_0\":\"a boolean value that corresponds to whether the address with the proof has been verified in the past or if they exist in the current merkle tree.\"}}},\"title\":\"Allowlist\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":\"Creates this contract and sets the PoolCap of 0x0 with uint256(0x54dd1e) for crude checking whether an address holds this contract.\",\"getPoolAccountLimit(address)\":{\"notice\":\"Returns the max mintable amount of the lp token per account in given pool address.\"},\"getPoolCap(address)\":{\"notice\":\"Returns the maximum total supply of the pool token for the given pool address.\"},\"isAccountVerified(address)\":{\"notice\":\"Returns true if the given account's existence has been verified against any of the past or the present merkle tree. Note that if it has been verified in the past, this function will return true even if the current merkle tree does not contain the account.\"},\"setPoolAccountLimit(address,uint256)\":{\"notice\":\"Sets the account limit of allowed deposit amounts for the given pool\"},\"setPoolCap(address,uint256)\":{\"notice\":\"Sets the max total supply of LPToken for the given pool address\"},\"updateMerkleRoot(bytes32)\":{\"notice\":\"Updates the merkle root that is stored in this contract. This can only be called by the owner. If more addresses are added to the list, a new merkle tree and a merkle root node should be generated, and merkleRoot should be updated accordingly.\"},\"verifyAddress(address,bytes32[])\":{\"notice\":\"Checks the existence of keccak256(account) as a node in the merkle tree inferred by the merkle root node stored in this contract. Pools should use this function to check if the given address qualifies for depositing. If the given account has already been verified with the correct merkleProof, this function will return true when merkleProof is empty. The verified status will be overwritten if the previously verified user calls this function with an incorrect merkleProof.\"}},\"notice\":\"This contract is a registry holding information about how much each swap contract should contain upto. Swap.sol will rely on this contract to determine whether the pool cap is reached and also whether a user's deposit limit is reached.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/stable_swap/guarded/Allowlist.sol\":\"Allowlist\"},\"evmVersion\":\"istanbul\",\"libraries\":{\"__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x15e2d5bd4c28a88548074c54d220e8086f638a71ed07e6b3ba5a70066fcf458d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\",\"keccak256\":\"0x782ac63a026ef1d6ab242478016bf7006074726786de9a94bc6c0c33a87dd40d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xcc78a17dd88fa5a2edc60c8489e2f405c0913b377216a5b26b35656b2d0dab52\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x8d3cb350f04ff49cfb10aef08d87f19dcbaecc8027b0bed12f3275cd12f38cf0\",\"license\":\"MIT\"},\"contracts/stable_swap/guarded/Allowlist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\nimport \\\"../interfaces/IAllowlist.sol\\\";\\n\\n/**\\n * @title Allowlist\\n * @notice This contract is a registry holding information about how much each swap contract should\\n * contain upto. Swap.sol will rely on this contract to determine whether the pool cap is reached and\\n * also whether a user's deposit limit is reached.\\n */\\ncontract Allowlist is Ownable, IAllowlist {\\n    using SafeMath for uint256;\\n\\n    // Represents the root node of merkle tree containing a list of eligible addresses\\n    bytes32 public merkleRoot;\\n    // Maps pool address -> maximum total supply\\n    mapping(address => uint256) private poolCaps;\\n    // Maps pool address -> maximum amount of pool token mintable per account\\n    mapping(address => uint256) private accountLimits;\\n    // Maps account address -> boolean value indicating whether it has been checked and verified against the merkle tree\\n    mapping(address => bool) private verified;\\n\\n    event PoolCap(address indexed poolAddress, uint256 poolCap);\\n    event PoolAccountLimit(address indexed poolAddress, uint256 accountLimit);\\n    event NewMerkleRoot(bytes32 merkleRoot);\\n\\n    /**\\n     * @notice Creates this contract and sets the PoolCap of 0x0 with uint256(0x54dd1e) for\\n     * crude checking whether an address holds this contract.\\n     * @param merkleRoot_ bytes32 that represent a merkle root node. This is generated off chain with the list of\\n     * qualifying addresses.\\n     */\\n    constructor(bytes32 merkleRoot_) public {\\n        merkleRoot = merkleRoot_;\\n\\n        // This value will be used as a way of crude checking whether an address holds this Allowlist contract\\n        // Value 0x54dd1e has no inherent meaning other than it is arbitrary value that checks for\\n        // user error.\\n        poolCaps[address(0x0)] = uint256(0x54dd1e);\\n        emit PoolCap(address(0x0), uint256(0x54dd1e));\\n        emit NewMerkleRoot(merkleRoot_);\\n    }\\n\\n    /**\\n     * @notice Returns the max mintable amount of the lp token per account in given pool address.\\n     * @param poolAddress address of the pool\\n     * @return max mintable amount of the lp token per account\\n     */\\n    function getPoolAccountLimit(address poolAddress) external view override returns (uint256) {\\n        return accountLimits[poolAddress];\\n    }\\n\\n    /**\\n     * @notice Returns the maximum total supply of the pool token for the given pool address.\\n     * @param poolAddress address of the pool\\n     */\\n    function getPoolCap(address poolAddress) external view override returns (uint256) {\\n        return poolCaps[poolAddress];\\n    }\\n\\n    /**\\n     * @notice Returns true if the given account's existence has been verified against any of the past or\\n     * the present merkle tree. Note that if it has been verified in the past, this function will return true\\n     * even if the current merkle tree does not contain the account.\\n     * @param account the address to check if it has been verified\\n     * @return a boolean value representing whether the account has been verified in the past or the present merkle tree\\n     */\\n    function isAccountVerified(address account) external view returns (bool) {\\n        return verified[account];\\n    }\\n\\n    /**\\n     * @notice Checks the existence of keccak256(account) as a node in the merkle tree inferred by the merkle root node\\n     * stored in this contract. Pools should use this function to check if the given address qualifies for depositing.\\n     * If the given account has already been verified with the correct merkleProof, this function will return true when\\n     * merkleProof is empty. The verified status will be overwritten if the previously verified user calls this function\\n     * with an incorrect merkleProof.\\n     * @param account address to confirm its existence in the merkle tree\\n     * @param merkleProof data that is used to prove the existence of given parameters. This is generated\\n     * during the creation of the merkle tree. Users should retrieve this data off-chain.\\n     * @return a boolean value that corresponds to whether the address with the proof has been verified in the past\\n     * or if they exist in the current merkle tree.\\n     */\\n    function verifyAddress(address account, bytes32[] calldata merkleProof) external override returns (bool) {\\n        if (merkleProof.length != 0) {\\n            // Verify the account exists in the merkle tree via the MerkleProof library\\n            bytes32 node = keccak256(abi.encodePacked(account));\\n            if (MerkleProof.verify(merkleProof, merkleRoot, node)) {\\n                verified[account] = true;\\n                return true;\\n            }\\n        }\\n        return verified[account];\\n    }\\n\\n    // ADMIN FUNCTIONS\\n\\n    /**\\n     * @notice Sets the account limit of allowed deposit amounts for the given pool\\n     * @param poolAddress address of the pool\\n     * @param accountLimit the max number of the pool token a single user can mint\\n     */\\n    function setPoolAccountLimit(address poolAddress, uint256 accountLimit) external onlyOwner {\\n        require(poolAddress != address(0x0), \\\"0x0 is not a pool address\\\");\\n        accountLimits[poolAddress] = accountLimit;\\n        emit PoolAccountLimit(poolAddress, accountLimit);\\n    }\\n\\n    /**\\n     * @notice Sets the max total supply of LPToken for the given pool address\\n     * @param poolAddress address of the pool\\n     * @param poolCap the max total supply of the pool token\\n     */\\n    function setPoolCap(address poolAddress, uint256 poolCap) external onlyOwner {\\n        require(poolAddress != address(0x0), \\\"0x0 is not a pool address\\\");\\n        poolCaps[poolAddress] = poolCap;\\n        emit PoolCap(poolAddress, poolCap);\\n    }\\n\\n    /**\\n     * @notice Updates the merkle root that is stored in this contract. This can only be called by\\n     * the owner. If more addresses are added to the list, a new merkle tree and a merkle root node should be generated,\\n     * and merkleRoot should be updated accordingly.\\n     * @param merkleRoot_ a new merkle root node that contains a list of deposit allowed addresses\\n     */\\n    function updateMerkleRoot(bytes32 merkleRoot_) external onlyOwner {\\n        merkleRoot = merkleRoot_;\\n        emit NewMerkleRoot(merkleRoot_);\\n    }\\n}\\n\",\"keccak256\":\"0xa310b8ecb1e957e8b47de3361b4602174e2b35caf20ddef270712bb742049d99\",\"license\":\"MIT\"},\"contracts/stable_swap/interfaces/IAllowlist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IAllowlist {\\n    function getPoolAccountLimit(address poolAddress) external view returns (uint256);\\n\\n    function getPoolCap(address poolAddress) external view returns (uint256);\\n\\n    function verifyAddress(address account, bytes32[] calldata merkleProof) external returns (bool);\\n}\\n\",\"keccak256\":\"0xa9f02d6ef4b19ce07451f0f326ae0aa28fb3d186713be3db14f6046108c413b6\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051610aa8380380610aa88339818101604052602081101561003357600080fd5b5051600061003f61012e565b600080546001600160a01b0319166001600160a01b0383169081178255604051929350917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a35060018190556000808052600260209081526254dd1e7fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b81905560408051918252517f87a8ed40e9bdf0609701a63c1db365301c953ffa230215ac92903d4af963e7cd929181900390910190a26040805182815290517f2f4f633f2174c8fce0ce6b22ea3cc69675584063adfd3d25e4dc3fd50cb631fc9181900360200190a150610132565b3390565b610967806101416000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c80638da5cb5b116100715780638da5cb5b14610155578063945f1838146101795780639c8d8dea1461019f578063aed59dcc1461021f578063eb88f73e1461024b578063f2fde38b14610271576100a9565b80632eb4a7ab146100ae5780634783f0ef146100c85780634a982176146100e7578063715018a6146101135780638ba209b61461011b575b600080fd5b6100b6610297565b60408051918252519081900360200190f35b6100e5600480360360208110156100de57600080fd5b503561029d565b005b6100e5600480360360408110156100fd57600080fd5b506001600160a01b03813516906020013561033a565b6100e5610447565b6101416004803603602081101561013157600080fd5b50356001600160a01b03166104f3565b604080519115158252519081900360200190f35b61015d610511565b604080516001600160a01b039092168252519081900360200190f35b6100b66004803603602081101561018f57600080fd5b50356001600160a01b0316610520565b610141600480360360408110156101b557600080fd5b6001600160a01b0382351691908101906040810160208201356401000000008111156101e057600080fd5b8201836020820111156101f257600080fd5b8035906020019184602083028401116401000000008311171561021457600080fd5b50909250905061053b565b6100e56004803603604081101561023557600080fd5b506001600160a01b038135169060200135610614565b6100b66004803603602081101561026157600080fd5b50356001600160a01b0316610721565b6100e56004803603602081101561028757600080fd5b50356001600160a01b031661073c565b60015481565b6102a561083e565b6001600160a01b03166102b6610511565b6001600160a01b0316146102ff576040805162461bcd60e51b81526020600482018190526024820152600080516020610912833981519152604482015290519081900360640190fd5b60018190556040805182815290517f2f4f633f2174c8fce0ce6b22ea3cc69675584063adfd3d25e4dc3fd50cb631fc9181900360200190a150565b61034261083e565b6001600160a01b0316610353610511565b6001600160a01b03161461039c576040805162461bcd60e51b81526020600482018190526024820152600080516020610912833981519152604482015290519081900360640190fd5b6001600160a01b0382166103f3576040805162461bcd60e51b8152602060048201526019602482015278307830206973206e6f74206120706f6f6c206164647265737360381b604482015290519081900360640190fd5b6001600160a01b038216600081815260036020908152604091829020849055815184815291517ff30f0cdb7dc669285a3f39e2b5869ad68e12f7e2dc2234f6976f090e92031f9e9281900390910190a25050565b61044f61083e565b6001600160a01b0316610460610511565b6001600160a01b0316146104a9576040805162461bcd60e51b81526020600482018190526024820152600080516020610912833981519152604482015290519081900360640190fd5b600080546040516001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a3600080546001600160a01b0319169055565b6001600160a01b031660009081526004602052604090205460ff1690565b6000546001600160a01b031690565b6001600160a01b031660009081526002602052604090205490565b600081156105ef5760008460405160200180826001600160a01b031660601b81526014019150506040516020818303038152906040528051906020012090506105bb848480806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250506001549150849050610842565b156105ed5750506001600160a01b0383166000908152600460205260409020805460ff1916600190811790915561060d565b505b506001600160a01b03831660009081526004602052604090205460ff165b9392505050565b61061c61083e565b6001600160a01b031661062d610511565b6001600160a01b031614610676576040805162461bcd60e51b81526020600482018190526024820152600080516020610912833981519152604482015290519081900360640190fd5b6001600160a01b0382166106cd576040805162461bcd60e51b8152602060048201526019602482015278307830206973206e6f74206120706f6f6c206164647265737360381b604482015290519081900360640190fd5b6001600160a01b038216600081815260026020908152604091829020849055815184815291517f87a8ed40e9bdf0609701a63c1db365301c953ffa230215ac92903d4af963e7cd9281900390910190a25050565b6001600160a01b031660009081526003602052604090205490565b61074461083e565b6001600160a01b0316610755610511565b6001600160a01b03161461079e576040805162461bcd60e51b81526020600482018190526024820152600080516020610912833981519152604482015290519081900360640190fd5b6001600160a01b0381166107e35760405162461bcd60e51b81526004018080602001828103825260268152602001806108ec6026913960400191505060405180910390fd5b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b3390565b600081815b85518110156108e057600086828151811061085e57fe5b602002602001015190508083116108a557828160405160200180838152602001828152602001925050506040516020818303038152906040528051906020012092506108d7565b808360405160200180838152602001828152602001925050506040516020818303038152906040528051906020012092505b50600101610847565b50909214939250505056fe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573734f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572a264697066735822122001b746f6a5ccddeb48d44fec951c59c2ce89cab7c3b403456d68f2a31818d06864736f6c634300060c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100a95760003560e01c80638da5cb5b116100715780638da5cb5b14610155578063945f1838146101795780639c8d8dea1461019f578063aed59dcc1461021f578063eb88f73e1461024b578063f2fde38b14610271576100a9565b80632eb4a7ab146100ae5780634783f0ef146100c85780634a982176146100e7578063715018a6146101135780638ba209b61461011b575b600080fd5b6100b6610297565b60408051918252519081900360200190f35b6100e5600480360360208110156100de57600080fd5b503561029d565b005b6100e5600480360360408110156100fd57600080fd5b506001600160a01b03813516906020013561033a565b6100e5610447565b6101416004803603602081101561013157600080fd5b50356001600160a01b03166104f3565b604080519115158252519081900360200190f35b61015d610511565b604080516001600160a01b039092168252519081900360200190f35b6100b66004803603602081101561018f57600080fd5b50356001600160a01b0316610520565b610141600480360360408110156101b557600080fd5b6001600160a01b0382351691908101906040810160208201356401000000008111156101e057600080fd5b8201836020820111156101f257600080fd5b8035906020019184602083028401116401000000008311171561021457600080fd5b50909250905061053b565b6100e56004803603604081101561023557600080fd5b506001600160a01b038135169060200135610614565b6100b66004803603602081101561026157600080fd5b50356001600160a01b0316610721565b6100e56004803603602081101561028757600080fd5b50356001600160a01b031661073c565b60015481565b6102a561083e565b6001600160a01b03166102b6610511565b6001600160a01b0316146102ff576040805162461bcd60e51b81526020600482018190526024820152600080516020610912833981519152604482015290519081900360640190fd5b60018190556040805182815290517f2f4f633f2174c8fce0ce6b22ea3cc69675584063adfd3d25e4dc3fd50cb631fc9181900360200190a150565b61034261083e565b6001600160a01b0316610353610511565b6001600160a01b03161461039c576040805162461bcd60e51b81526020600482018190526024820152600080516020610912833981519152604482015290519081900360640190fd5b6001600160a01b0382166103f3576040805162461bcd60e51b8152602060048201526019602482015278307830206973206e6f74206120706f6f6c206164647265737360381b604482015290519081900360640190fd5b6001600160a01b038216600081815260036020908152604091829020849055815184815291517ff30f0cdb7dc669285a3f39e2b5869ad68e12f7e2dc2234f6976f090e92031f9e9281900390910190a25050565b61044f61083e565b6001600160a01b0316610460610511565b6001600160a01b0316146104a9576040805162461bcd60e51b81526020600482018190526024820152600080516020610912833981519152604482015290519081900360640190fd5b600080546040516001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a3600080546001600160a01b0319169055565b6001600160a01b031660009081526004602052604090205460ff1690565b6000546001600160a01b031690565b6001600160a01b031660009081526002602052604090205490565b600081156105ef5760008460405160200180826001600160a01b031660601b81526014019150506040516020818303038152906040528051906020012090506105bb848480806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250506001549150849050610842565b156105ed5750506001600160a01b0383166000908152600460205260409020805460ff1916600190811790915561060d565b505b506001600160a01b03831660009081526004602052604090205460ff165b9392505050565b61061c61083e565b6001600160a01b031661062d610511565b6001600160a01b031614610676576040805162461bcd60e51b81526020600482018190526024820152600080516020610912833981519152604482015290519081900360640190fd5b6001600160a01b0382166106cd576040805162461bcd60e51b8152602060048201526019602482015278307830206973206e6f74206120706f6f6c206164647265737360381b604482015290519081900360640190fd5b6001600160a01b038216600081815260026020908152604091829020849055815184815291517f87a8ed40e9bdf0609701a63c1db365301c953ffa230215ac92903d4af963e7cd9281900390910190a25050565b6001600160a01b031660009081526003602052604090205490565b61074461083e565b6001600160a01b0316610755610511565b6001600160a01b03161461079e576040805162461bcd60e51b81526020600482018190526024820152600080516020610912833981519152604482015290519081900360640190fd5b6001600160a01b0381166107e35760405162461bcd60e51b81526004018080602001828103825260268152602001806108ec6026913960400191505060405180910390fd5b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b3390565b600081815b85518110156108e057600086828151811061085e57fe5b602002602001015190508083116108a557828160405160200180838152602001828152602001925050506040516020818303038152906040528051906020012092506108d7565b808360405160200180838152602001828152602001925050506040516020818303038152906040528051906020012092505b50600101610847565b50909214939250505056fe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573734f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572a264697066735822122001b746f6a5ccddeb48d44fec951c59c2ce89cab7c3b403456d68f2a31818d06864736f6c634300060c0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "merkleRoot_": "bytes32 that represent a merkle root node. This is generated off chain with the list of qualifying addresses."
        }
      },
      "getPoolAccountLimit(address)": {
        "params": {
          "poolAddress": "address of the pool"
        },
        "returns": {
          "_0": "max mintable amount of the lp token per account"
        }
      },
      "getPoolCap(address)": {
        "params": {
          "poolAddress": "address of the pool"
        }
      },
      "isAccountVerified(address)": {
        "params": {
          "account": "the address to check if it has been verified"
        },
        "returns": {
          "_0": "a boolean value representing whether the account has been verified in the past or the present merkle tree"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "setPoolAccountLimit(address,uint256)": {
        "params": {
          "accountLimit": "the max number of the pool token a single user can mint",
          "poolAddress": "address of the pool"
        }
      },
      "setPoolCap(address,uint256)": {
        "params": {
          "poolAddress": "address of the pool",
          "poolCap": "the max total supply of the pool token"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "updateMerkleRoot(bytes32)": {
        "params": {
          "merkleRoot_": "a new merkle root node that contains a list of deposit allowed addresses"
        }
      },
      "verifyAddress(address,bytes32[])": {
        "params": {
          "account": "address to confirm its existence in the merkle tree",
          "merkleProof": "data that is used to prove the existence of given parameters. This is generated during the creation of the merkle tree. Users should retrieve this data off-chain."
        },
        "returns": {
          "_0": "a boolean value that corresponds to whether the address with the proof has been verified in the past or if they exist in the current merkle tree."
        }
      }
    },
    "title": "Allowlist",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": "Creates this contract and sets the PoolCap of 0x0 with uint256(0x54dd1e) for crude checking whether an address holds this contract.",
      "getPoolAccountLimit(address)": {
        "notice": "Returns the max mintable amount of the lp token per account in given pool address."
      },
      "getPoolCap(address)": {
        "notice": "Returns the maximum total supply of the pool token for the given pool address."
      },
      "isAccountVerified(address)": {
        "notice": "Returns true if the given account's existence has been verified against any of the past or the present merkle tree. Note that if it has been verified in the past, this function will return true even if the current merkle tree does not contain the account."
      },
      "setPoolAccountLimit(address,uint256)": {
        "notice": "Sets the account limit of allowed deposit amounts for the given pool"
      },
      "setPoolCap(address,uint256)": {
        "notice": "Sets the max total supply of LPToken for the given pool address"
      },
      "updateMerkleRoot(bytes32)": {
        "notice": "Updates the merkle root that is stored in this contract. This can only be called by the owner. If more addresses are added to the list, a new merkle tree and a merkle root node should be generated, and merkleRoot should be updated accordingly."
      },
      "verifyAddress(address,bytes32[])": {
        "notice": "Checks the existence of keccak256(account) as a node in the merkle tree inferred by the merkle root node stored in this contract. Pools should use this function to check if the given address qualifies for depositing. If the given account has already been verified with the correct merkleProof, this function will return true when merkleProof is empty. The verified status will be overwritten if the previously verified user calls this function with an incorrect merkleProof."
      }
    },
    "notice": "This contract is a registry holding information about how much each swap contract should contain upto. Swap.sol will rely on this contract to determine whether the pool cap is reached and also whether a user's deposit limit is reached.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4512,
        "contract": "contracts/stable_swap/guarded/Allowlist.sol:Allowlist",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 29704,
        "contract": "contracts/stable_swap/guarded/Allowlist.sol:Allowlist",
        "label": "merkleRoot",
        "offset": 0,
        "slot": "1",
        "type": "t_bytes32"
      },
      {
        "astId": 29708,
        "contract": "contracts/stable_swap/guarded/Allowlist.sol:Allowlist",
        "label": "poolCaps",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 29712,
        "contract": "contracts/stable_swap/guarded/Allowlist.sol:Allowlist",
        "label": "accountLimits",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 29716,
        "contract": "contracts/stable_swap/guarded/Allowlist.sol:Allowlist",
        "label": "verified",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}